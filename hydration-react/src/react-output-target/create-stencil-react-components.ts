import type { ComponentCompilerMeta } from '@stencil/core/internal';
import { Project, VariableDeclarationKind } from 'ts-morph';
import { eventListenerName, kebabToPascalCase, kebabToCamelCase, attachJsDoc } from './utils/string-utils';

interface ReactEvent {
  originalName: string;
  name: string;
  type: string;
}
interface ReactSlot {
  originalName: string;
  name: string;
  docs: string;
}

const CONTEXT_COMPONENTS = ['ks-form', 'ks-form-item', 'ks-form-list'];

export const createStencilReactComponents = ({
  components,
  stencilPackageName,
  customElementsDir,
  defaultExport = false,
  hydrateModule,
  excludeServerSideRenderingFor,
  aliasEventNames,
  tagNameTransform = false,
  tagNameSuffix = '',
}: {
  components: ComponentCompilerMeta[];
  stencilPackageName: string;
  customElementsDir: string;
  defaultExport?: boolean;
  hydrateModule?: string;
  excludeServerSideRenderingFor?: string[];
  aliasEventNames?: (eventName: string) => string;
  tagNameTransform?: boolean;
  tagNameSuffix: string;
}) => {
  const project = new Project({ useInMemoryFileSystem: true });
  const excludeSSRComponents = excludeServerSideRenderingFor || [];

  /**
   * automatically attach the `use client` directive if we are not generating
   * server side rendering components.
   */
  const useClientDirective = !hydrateModule ? "'use client';\n\n" : '';
  const importDirections = hydrateModule
    ? `
 * Do __not__ import components from this file as server side rendered components
 * may not hydrate due to missing Stencil runtime. Instead, import these components through the generated 'components.ts'
 * file that re-exports all components with the 'use client' directive.`
    : '';

  const autogeneratedComment = `/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.${importDirections}
 */\n\n`;

  const disableEslint = '/* eslint-disable */\n';

  const runtimeImports = hydrateModule
    ? 'createComponent, createSSRComponent, createContextComponent'
    : 'createComponent, createContextComponent';
  const sourceFile = project.createSourceFile(
    'component.ts',
    `${useClientDirective}${autogeneratedComment}${disableEslint}
import React from 'react';
import { ${runtimeImports} } from '@byted-keystone/react-output-target/runtime';
import type { EventName, StencilReactComponent, ComponentProps } from '@byted-keystone/react-output-target/runtime';
  `,
  );

  for (const component of components) {
    const { tagName } = component;
    const reactTagName = kebabToPascalCase(tagName);
    const componentElement = `${reactTagName}Element`;
    const componentCustomEvent = `${reactTagName}CustomEvent`;

    sourceFile.addImportDeclaration({
      moduleSpecifier: `${stencilPackageName}/${customElementsDir}/${tagName}.js`,
      namedImports: [
        {
          name: reactTagName,
          alias: componentElement,
        },
        {
          name: 'defineCustomElement',
          alias: `define${reactTagName}`,
        },
      ],
    });

    // eslint-disable-next-line no-autofix/@typescript-eslint/no-unnecessary-boolean-literal-compare
    const publicEvents = (component.events || []).filter((e) => e.internal === false);

    const events: ReactEvent[] = [];
    const slots: ReactSlot[] = parseComponentSlots(component);

    for (const event of publicEvents) {
      const eventNameAlias = aliasEventNames?.(event.name) ?? event.name;

      if (Object.keys(event.complexType.references).length > 0) {
        /**
         * Import the referenced types from the component library.
         * Stencil will automatically re-export type definitions from the components,
         * if they are used in the component's property or event types.
         */
        for (const referenceKey of Object.keys(event.complexType.references)) {
          const reference = event.complexType.references[referenceKey];
          const isGlobalType = reference.location === 'global';
          /**
           * Global type references should not have an explicit import.
           * The type should be available globally.
           */
          if (!isGlobalType) {
            sourceFile.addImportDeclaration({
              moduleSpecifier: stencilPackageName,
              namedImports: [
                {
                  name: referenceKey,
                  isTypeOnly: true,
                },
              ],
            });
          }
        }

        /**
         * Import the CustomEvent type for the web component from the Stencil package.
         *
         * For example:
         * ```
         * import type { ComponentCustomEvent } from 'my-component-library';
         * ```
         */
        sourceFile.addImportDeclaration({
          moduleSpecifier: stencilPackageName,
          namedImports: [
            {
              name: componentCustomEvent,
              isTypeOnly: true,
            },
          ],
        });

        events.push({
          originalName: event.name,
          name: eventListenerName(eventNameAlias),
          type: `EventName<${event.complexType.original}>`,
        });
      } else {
        events.push({
          originalName: event.name,
          name: eventListenerName(eventNameAlias),
          type: `EventName<${event.complexType.original}>`,
        });
      }
    }

    const componentSlotsType = `${reactTagName}Slots`;
    const componentEventNamesType = `${reactTagName}Events`;

    sourceFile.addTypeAliases([
      {
        name: componentSlotsType,
        type:
          slots.length > 0
            ? `{ ${slots.map((e) => `${e.docs.length ? attachJsDoc(e.docs) : ''}${e.name}: string`).join(',')} }`
            : 'NonNullable<unknown>',
      },
      {
        name: componentEventNamesType,
        type:
          events.length > 0 ? `{ ${events.map((e) => `${e.name}: ${e.type}`).join(',\n')} }` : 'NonNullable<unknown>',
      },
      {
        name: `${reactTagName}Props`,
        type: `ComponentProps<${componentElement}, ${componentEventNamesType}, ${componentSlotsType}>`,
        isExported: true,
      },
    ]);

    const createComponent = CONTEXT_COMPONENTS.some((tag) => tag === tagName)
      ? 'createContextComponent'
      : 'createComponent';

    const clientComponentCall = `/*@__PURE__*/ ${createComponent}<${componentElement}, ${componentEventNamesType}, ${componentSlotsType}>({
    tagName: '${tagName}${tagNameSuffix}',
    elementClass: ${componentElement},
    // @ts-ignore - React type of Stencil Output Target may differ from the React version used in the Nuxt.js project, this can be ignored.
    react: React,
    events: {${events.map((e) => `${e.name}: '${e.originalName}'`).join(',\n')}} as ${componentEventNamesType},
    slots: {${slots.map((e) => `${e.name}: '${e.originalName}'`).join(',\n')}} as ${componentSlotsType},
    displayName: '${reactTagName}',
    defineCustomElement: define${reactTagName},
    tagNameTransform: ${tagNameTransform}
  })`;
    const serverComponentCall = `/*@__PURE__*/ createSSRComponent<${componentElement}, ${componentEventNamesType}>({
    tagName: '${tagName}${tagNameSuffix}',
    properties: {${component.properties
      /**
       * Filter out properties that don't have an attribute.
       * These are properties with complex types and can't be serialized.
       */
      .filter((prop) => Boolean(prop.attribute))
      .map((e) => `${e.name}: '${e.attribute}'`)
      .join(',\n')}},
    hydrateModule: import('${hydrateModule}'),
    tagNameTransform: ${tagNameTransform}
  })`;

    const statement = sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      // React as never is a hack to by-pass a @types/react issue.
      declarations: [
        {
          name: reactTagName,
          type: `StencilReactComponent<${componentElement}, ${componentEventNamesType}, ${componentSlotsType}>`,
          initializer:
            hydrateModule && !excludeSSRComponents.includes(tagName)
              ? `typeof window !== 'undefined'
                ? ${clientComponentCall}
                : ${serverComponentCall}`
              : clientComponentCall,
        },
      ],
    });

    if (defaultExport) {
      sourceFile.addExportAssignment({
        isExportEquals: false,
        expression: reactTagName,
      });
    } else {
      statement.setIsExported(true);
    }
  }

  sourceFile.organizeImports();
  sourceFile.formatText();

  return sourceFile.getFullText();
};

const DEFAULT_SLOTNAME = 'default';
const SLOT_DOCS_SPLITTER = ' - ';
const parseComponentSlots = (component: ComponentCompilerMeta): ReactSlot[] =>
  component.docs.tags
    .filter(({ name, text }) => name === 'slot' && text)
    .map(({ text = '' }): ReactSlot => {
      const splitterIndex = text.indexOf(SLOT_DOCS_SPLITTER);

      const originalName = (splitterIndex > 0 ? text.substring(0, splitterIndex) : text).trim();
      const name = kebabToCamelCase(originalName);
      const docs = text.substring(splitterIndex + SLOT_DOCS_SPLITTER.length) || '';

      return { originalName, name, docs };
    })
    .filter(({ originalName }) => originalName !== DEFAULT_SLOTNAME);
