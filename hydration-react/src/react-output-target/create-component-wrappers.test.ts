import { dedent } from 'ts-dedent';
import { Project } from 'ts-morph';
import { describe, expect, it } from 'vitest';

import { createComponentWrappers } from './create-component-wrappers';

describe('createComponentWrappers', () => {
  it('should generate a react component wrapper', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component',
          componentClassName: 'MyComponent',
          properties: [],
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              type: 'CustomEvent',
            },
          ],
          docs: { tags: [] },
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      project,
    });

    const sourceFile = sourceFiles[0];

    expect(sourceFile.getFullText()).toEqual(dedent`'use client';

/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 */

/* eslint-disable */

import type { ComponentProps, StencilReactComponent } from '@byted-keystone/react-output-target/runtime';
import { createComponent } from '@byted-keystone/react-output-target/runtime';
import { MyComponent as MyComponentElement, defineCustomElement as defineMyComponent } from "my-package/dist/custom-elements/my-component.js";
import React from 'react';

type MyComponentSlots = NonNullable<unknown>;
type MyComponentEvents = NonNullable<unknown>;
export type MyComponentProps = ComponentProps<MyComponentElement, MyComponentEvents, MyComponentSlots>;

export const MyComponent: StencilReactComponent<MyComponentElement, MyComponentEvents, MyComponentSlots> = /*@__PURE__*/ createComponent<MyComponentElement, MyComponentEvents, MyComponentSlots>({
    tagName: 'my-component',
    elementClass: MyComponentElement,
    // @ts-ignore - React type of Stencil Output Target may differ from the React version used in the Nuxt.js project, this can be ignored.
    react: React,
    events: {} as MyComponentEvents,
    slots: {} as MyComponentSlots,
    displayName: 'MyComponent',
    defineCustomElement: defineMyComponent,
    tagNameTransform: false
});

`);
  });

  it('should generate a react component wrapper with ES modules', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component',
          componentClassName: 'MyComponent',
          properties: [],
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              type: 'CustomEvent',
            },
          ],
          docs: { tags: [] },
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      esModules: true,
      project,
    });

    const sourceFile = sourceFiles[0];

    expect(sourceFile.getFullText()).toEqual(dedent`'use client';

/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 */

/* eslint-disable */

import type { ComponentProps, StencilReactComponent } from '@byted-keystone/react-output-target/runtime';
import { createComponent } from '@byted-keystone/react-output-target/runtime';
import { MyComponent as MyComponentElement, defineCustomElement as defineMyComponent } from "my-package/dist/custom-elements/my-component.js";
import React from 'react';

type MyComponentSlots = NonNullable<unknown>;
type MyComponentEvents = NonNullable<unknown>;
export type MyComponentProps = ComponentProps<MyComponentElement, MyComponentEvents, MyComponentSlots>;

const MyComponent: StencilReactComponent<MyComponentElement, MyComponentEvents, MyComponentSlots> = /*@__PURE__*/ createComponent<MyComponentElement, MyComponentEvents, MyComponentSlots>({
    tagName: 'my-component',
    elementClass: MyComponentElement,
    // @ts-ignore - React type of Stencil Output Target may differ from the React version used in the Nuxt.js project, this can be ignored.
    react: React,
    events: {} as MyComponentEvents,
    slots: {} as MyComponentSlots,
    displayName: 'MyComponent',
    defineCustomElement: defineMyComponent,
    tagNameTransform: false
});

export default MyComponent;

`);
  });

  it('should not generate component wrappers for internal components', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component',
          properties: [],
          internal: true,
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      esModules: false,
      project,
    });

    expect(sourceFiles).toEqual([]);
  });

  it('should filter out excludedComponents', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component',
          componentClassName: 'MyComponent',
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              type: 'CustomEvent',
            },
          ],
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      esModules: false,
      excludeComponents: ['my-component'],
      project,
    });

    expect(sourceFiles).toEqual([]);
  });

  it('should generate event types from references', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component',
          componentClassName: 'MyComponent',
          properties: [],
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              internal: false,
              complexType: {
                original: 'IMyComponent.Events.Detail.MyComponentClicked',
                resolved: '{ element: HTMLMyComponentElement; context: MyComponent; event: Event; }',
                references: {
                  IButton: {
                    location: 'import',
                    path: '../../types/my-component',
                    id: 'src/types/my-component.d.ts::IMyComponent',
                  },
                },
              },
            },
          ],
          docs: { tags: [] },
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      esModules: false,
      project,
    });

    const sourceFile = sourceFiles[0];

    expect(sourceFile.getFullText()).toEqual(dedent`'use client';

/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 */

/* eslint-disable */

import type { ComponentProps, EventName, StencilReactComponent } from '@byted-keystone/react-output-target/runtime';
import { createComponent } from '@byted-keystone/react-output-target/runtime';
import { MyComponent as MyComponentElement, defineCustomElement as defineMyComponent } from "my-package/dist/custom-elements/my-component.js";
import React from 'react';

type MyComponentSlots = NonNullable<unknown>;
type MyComponentEvents = { onMyEvent: EventName<IMyComponent.Events.Detail.MyComponentClicked> };
export type MyComponentProps = ComponentProps<MyComponentElement, MyComponentEvents, MyComponentSlots>;

export const MyComponent: StencilReactComponent<MyComponentElement, MyComponentEvents, MyComponentSlots> = /*@__PURE__*/ createComponent<MyComponentElement, MyComponentEvents, MyComponentSlots>({
    tagName: 'my-component',
    elementClass: MyComponentElement,
    // @ts-ignore - React type of Stencil Output Target may differ from the React version used in the Nuxt.js project, this can be ignored.
    react: React,
    events: { onMyEvent: 'myEvent' } as MyComponentEvents,
    slots: {} as MyComponentSlots,
    displayName: 'MyComponent',
    defineCustomElement: defineMyComponent,
    tagNameTransform: false
});

    `);
  });

  it('creates next.js component wrappers', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component',
          componentClassName: 'MyComponent',
          properties: [
            {
              name: 'hasMaxLength',
              attribute: 'max-length',
            },
            {
              name: 'links',
            },
          ],
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              type: 'CustomEvent',
            },
          ],
          docs: { tags: [] },
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      esModules: false,
      hydrateModule: 'my-package/hydrate',
      project,
    });

    const sourceFile = sourceFiles[0];

    const code = sourceFile.getFullText();
    expect(code).toContain('createComponent<MyComponentElement, MyComponentEvents, MyComponentSlots>({');
    expect(code).toContain('createSSRComponent<MyComponentElement, MyComponentEvents>({');
  });

  it('can exclude components for server side rendering', async () => {
    const project = new Project({ useInMemoryFileSystem: true });
    const sourceFiles = await createComponentWrappers({
      components: [
        {
          tagName: 'my-component-a',
          componentClassName: 'MyComponentA',
          properties: [
            {
              name: 'hasMaxLength',
              attribute: 'max-length',
            },
            {
              name: 'links',
            },
          ],
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              type: 'CustomEvent',
            },
          ],
          docs: { tags: [] },
        } as any,
        {
          tagName: 'my-component-b',
          componentClassName: 'MyComponentB',
          properties: [
            {
              name: 'hasMaxLength',
              attribute: 'max-length',
            },
            {
              name: 'links',
            },
          ],
          events: [
            {
              originalName: 'my-event',
              name: 'myEvent',
              type: 'CustomEvent',
            },
          ],
          docs: { tags: [] },
        } as any,
      ],
      stencilPackageName: 'my-package',
      customElementsDir: 'dist/custom-elements',
      outDir: 'dist/my-output-path',
      esModules: false,
      hydrateModule: 'my-package/hydrate',
      excludeServerSideRenderingFor: ['my-component-a'],
      project,
    });

    const sourceFile = sourceFiles[0];

    const code = sourceFile.getFullText();
    expect(code).toContain('createComponent<MyComponentAElement, MyComponentAEvents, MyComponentASlots>({');
    expect(code).not.toContain('createSSRComponent<MyComponentAElement, MyComponentAEvents>({');
    expect(code).toContain('createComponent<MyComponentBElement, MyComponentBEvents, MyComponentBSlots>({');
    expect(code).toContain('createSSRComponent<MyComponentBElement, MyComponentBEvents>({');
  });
});
