import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import Client from '@ies/starling_node';
import _ from 'lodash';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const PROJECT = 'byted_web_components';
const NAMESPACE = 'wc-ui';
const LOCALES = [
  'ar',
  'cs-CZ',
  'de',
  'en',
  'es',
  'fr',
  'id',
  'it',
  'ja',
  'ko',
  'ms',
  'pl-PL',
  'pt-BR',
  'ru',
  'sv-SE',
  'th',
  'tr',
  'vi',
  'zh',
  // FIXME 元强的 st-JO 如何处理
];
// GMPT 历史曾启用过的 locale 别名
const LOCALES_ALIASES = {
  'pt-BR': ['pt'],
};
const LOCALES_INDICES = LOCALES.reduce((acc, locale, index) => {
  acc[locale] = index;
  if (LOCALES_ALIASES[locale]) {
    LOCALES_ALIASES[locale].forEach((alias) => (acc[alias] = index));
  }
  return acc;
}, {});

const BASE_PATH = path.resolve(__dirname, '../src');
const CONSTANTS_FILE = path.resolve(BASE_PATH, 'constants.ts');
const INDEX_FILE = path.resolve(BASE_PATH, 'index.ts');

const client = new Client(PROJECT, NAMESPACE);

async function loadI18nText() {
  const allTranslations = {};
  const allKeys = new Set();

  console.log('Fetching translations for all languages...');
  await Promise.all(
    LOCALES.map(async (lang) => {
      try {
        const result = (await client.getPackage(lang)).data;
        allTranslations[lang] = result;
        Object.keys(result).forEach((key) => allKeys.add(key));
        console.log(`Successfully fetched translations for ${lang}`);
      } catch (error) {
        console.error(`Failed to fetch translations for ${lang}:`, error);
        allTranslations[lang] = {};
      }
    }),
  );

  const sortedKeys = Array.from(allKeys).sort();

  const groupedKeys = _.groupBy(sortedKeys, (key) => key.split(/[._]/)[0]);

  const constantsOutput = `// This file is auto generated by starling.js. DO NOT EDIT.
/* eslint-disable */

export const LOCALES_INDICES = ${JSON.stringify(LOCALES_INDICES, null, 2)};
`;
  console.log(`Writing constants to ${CONSTANTS_FILE}`);
  fs.writeFileSync(CONSTANTS_FILE, constantsOutput, { encoding: 'utf-8' });

  let indexOutput = `// This file is auto generated by starling.js. DO NOT EDIT.
/* eslint-disable */
import type { LocalizedMessage } from './utils';
export { LOCALES_INDICES } from './constants';

export { resolveMessage, isSupportedLocale, LocalizedMessage, Locale } from './utils';

// 翻译文案截止 0.4.3 版本 minified 后的体积只有 16KB (7KB gzipped)，并且支持 tree-shaking。
// 因此建议直接引入，无需动态加载，避免动态加载额外的网络和重渲染开销。
// The translations are only 16KB (7KB gzipped) minified till v0.4.3, and are tree-shakable.
// Therefore, it is recommended to directly import them instead of dynamically loading them.

`;

  for (const groupName in groupedKeys) {
    if (!groupName || groupName === 'undefined') {
      continue;
    }

    const keysInGroup = groupedKeys[groupName];
    const varName = `${_.camelCase(groupName)}Messages`;
    indexOutput += `export const ${varName} = {\n`;

    for (const key of keysInGroup) {
      const keySuffix = key.substring(groupName.length + 1);
      const propName = _.camelCase(keySuffix);

      if (!propName) {
        continue;
      }

      const translations = LOCALES.map((lang) =>
        (allTranslations[lang]?.[key] ?? '').replace(/\{\s*(.*?)\s*\}/g, '{$1}'),
      );

      const enTranslation = translations[LOCALES_INDICES.en] ?? '';
      const interpolationMatches = enTranslation.match(/\{(.*?)\}/g) ?? [];
      const interpolationKeys = [...new Set(interpolationMatches.map((match) => match.slice(1, -1)))];

      let localizedMessageType = 'LocalizedMessage<never>';
      if (interpolationKeys.length > 0) {
        const typeProperties = interpolationKeys.map((key) => `${key}: string | number`).join(', ');
        localizedMessageType = `LocalizedMessage<{ ${typeProperties} }>`;
      }

      indexOutput += `  ${propName}: ${JSON.stringify(translations)} as ${localizedMessageType},\n`;
    }

    indexOutput += `};\n\n`;
  }

  console.log(`Writing translations to ${INDEX_FILE}`);
  fs.writeFileSync(INDEX_FILE, indexOutput, {
    encoding: 'utf-8',
  });

  console.log('Cleaning up old language files...');
  for (const lang of LOCALES) {
    const oldFilePath = path.resolve(BASE_PATH, `${lang}.ts`);
    if (fs.existsSync(oldFilePath)) {
      fs.unlinkSync(oldFilePath);
      console.log(`Deleted ${oldFilePath}`);
    }
  }

  console.log('Done.');
}

loadI18nText()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
