{"version":3,"names":["createContext","key","ContextRequestEvent","Event","constructor","context","callback","subscribe","path","super","bubbles","composed","this","contextPath"],"sources":["src/libs/runtime-context/create-context.ts","src/libs/runtime-context/context-request-event.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * The Context type defines a type brand to associate a key value with the context value type\n */\nexport type Context<KeyType, ValueType> = KeyType & { __context__: ValueType };\n\n/**\n * @deprecated use Context instead\n */\nexport type ContextKey<KeyType, ValueType> = Context<KeyType, ValueType>;\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\nexport type ContextType<Key extends Context<unknown, unknown>> =\n  Key extends Context<unknown, infer ValueType> ? ValueType : never;\n\n/**\n * Creates a typed Context.\n *\n * Contexts are compared with strict equality.\n *\n * If you want two separate `createContext()` calls to referer to the same\n * context, then use a key that will by equal under strict equality like a\n * string for `Symbol.for()`:\n *\n * ```ts\n * // true\n * createContext('my-context') === createContext('my-context')\n * // true\n * createContext(Symbol.for('my-context')) === createContext(Symbol.for('my-context'))\n * ```\n *\n * If you want a context to be unique so that it's guaranteed to not collide\n * with other contexts, use a key that's unique under strict equality, like\n * a `Symbol()` or object.:\n *\n * ```\n * // false\n * createContext({}) === createContext({})\n * // false\n * createContext(Symbol('my-context')) === createContext(Symbol('my-context'))\n * ```\n *\n * @param key a context key value\n * @template ValueType the type of value that can be provided by this context.\n * @returns the context key value cast to `Context<K, ValueType>`\n */\nexport function createContext<ValueType, K = unknown>(key: K) {\n  return key as Context<K, ValueType>;\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { ContextType, Context } from './create-context';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-request' event can be emitted by any element which desires\n     * a context value to be injected by an external provider.\n     */\n    'context-request': ContextRequestEvent<Context<unknown, unknown>>;\n  }\n}\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\nexport type ContextCallback<ValueType> = (value: ValueType, unsubscribe?: () => void) => void;\n\n/**\n * Interface definition for a ContextRequest\n */\nexport interface ContextRequest<C extends Context<unknown, unknown>> {\n  readonly context: C;\n  readonly callback: ContextCallback<ContextType<C>>;\n  readonly subscribe?: boolean;\n  readonly contextPath?: string[] | Promise<() => string[]>;\n}\n\n/**\n * An event fired by a context requester to signal it desires a specified context with the given key.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * method to the callback which consumers can invoke to indicate they no longer wish to receive these updates.\n *\n * If no `subscribe` value is present in the event, then the provider can assume that this is a 'one time'\n * request for the context and can therefore not track the consumer.\n */\nexport class ContextRequestEvent<C extends Context<unknown, unknown>> extends Event implements ContextRequest<C> {\n  readonly context: C;\n  readonly callback: ContextCallback<ContextType<C>>;\n  readonly subscribe?: boolean;\n  readonly contextPath?: string[] | Promise<() => string[]>;\n\n  /**\n   *\n   * @param context the context key to request\n   * @param callback the callback that should be invoked when the context with the specified key is available\n   * @param subscribe when, true indicates we want to subscribe to future updates\n   * @param path optional path string or Promise<string> to specify which part of the context value to subscribe to\n   */\n  constructor(\n    context: C,\n    callback: ContextCallback<ContextType<C>>,\n    subscribe?: boolean,\n    path?: string[] | Promise<() => string[]>,\n  ) {\n    super('context-request', { bubbles: true, composed: true });\n    this.context = context;\n    this.callback = callback;\n    this.subscribe = subscribe ?? false;\n    this.contextPath = path;\n  }\n}\n"],"mappings":";;;;;AAqDM,SAAUA,EAAsCC,GACpD,OAAOA,CACT;;;;;GCRM,MAAOC,UAAiEC,MAa5E,WAAAC,CACEC,EACAC,EACAC,EACAC,GAEAC,MAAM,kBAAmB,CAAEC,QAAS,KAAMC,SAAU,OACpDC,KAAKP,QAAUA,EACfO,KAAKN,SAAWA,EAChBM,KAAKL,UAAYA,GAAa,MAC9BK,KAAKC,YAAcL,C","ignoreList":[]}