{"version":3,"names":["ContextConsumer","constructor","host","contextOrOptions","callback","subscribe","path","this","provided","value","undefined","_callback","unsubscribe","forceUpdate","context","options","hostConnected","dispatchRequest","hostDisconnected","dispatchEvent","ContextRequestEvent","Consume","target","propertyKey","originalConnectedCallback","connectedCallback","originalDisconnectedCallback","disconnectedCallback","consumerMap","WeakMap","consumer","getElement","Promise","res","__propsReady","then","bind","set","call","get","delete"],"sources":["src/libs/runtime-context/controllers/context-consumer.ts","src/libs/runtime-context/decorators/consume.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { forceUpdate } from '@stencil/core';\nimport { ContextCallback, ContextRequestEvent } from '../context-request-event';\nimport type { Context, ContextType } from '../create-context';\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  subscribe?: boolean;\n  path?: string[] | Promise<() => string[]>;\n}\n\nexport class ContextConsumer<C extends Context<unknown, unknown>, HostElement extends HTMLElement> {\n  protected host: HostElement;\n  private context: C;\n  private callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  private subscribe = false;\n  private path?: string[] | Promise<() => string[]>;\n\n  private provided = false;\n\n  value?: ContextType<C> = undefined;\n\n  constructor(host: HostElement, options: Options<C>);\n  constructor(\n    host: HostElement,\n    contextOrOptions: C | Options<C>,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean,\n    path?: string[] | Promise<() => string[]>,\n  ) {\n    this.host = host;\n    // This is a potentially fragile duck-type. It means a context object can't\n    // have a property name context and be used in positional argument form.\n    if ((contextOrOptions as Options<C>).context !== undefined) {\n      const options = contextOrOptions as Options<C>;\n      this.context = options.context;\n      this.callback = options.callback;\n      this.subscribe = options.subscribe ?? false;\n      this.path = options.path;\n    } else {\n      this.context = contextOrOptions as C;\n      this.callback = callback;\n      this.subscribe = subscribe ?? false;\n      this.path = path;\n    }\n  }\n\n  private unsubscribe?: () => void;\n\n  hostConnected(): void {\n    this.dispatchRequest();\n  }\n\n  hostDisconnected(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = undefined;\n    }\n  }\n\n  private dispatchRequest() {\n    this.host.dispatchEvent(new ContextRequestEvent(this.context, this._callback, this.subscribe, this.path));\n  }\n\n  // This function must have stable identity to properly dedupe in ContextRoot\n  // if this element connects multiple times.\n  private _callback: ContextCallback<ContextType<C>> = (value, unsubscribe) => {\n    // some providers will pass an unsubscribe function indicating they may provide future values\n    if (this.unsubscribe) {\n      // if the unsubscribe function changes this implies we have changed provider\n      if (this.unsubscribe !== unsubscribe) {\n        // cleanup the old provider\n        this.provided = false;\n        this.unsubscribe();\n      }\n      // if we don't support subscription, immediately unsubscribe\n      if (!this.subscribe) {\n        this.unsubscribe();\n      }\n    }\n\n    // store the value so that it can be retrieved from the controller\n    this.value = value;\n    // schedule an update in case this value is used in a template\n    forceUpdate(this.host);\n\n    // only invoke callback if we are either expecting updates or have not yet\n    // been provided a value\n    if (!this.provided || this.subscribe) {\n      this.provided = true;\n      if (this.callback) {\n        this.callback(value, unsubscribe);\n      }\n    }\n\n    this.unsubscribe = unsubscribe;\n  };\n}\n","/**\n * @license\n * Copyright 2024 ByteDance Inc.\n */\n\nimport { ComponentInterface, getElement } from '@stencil/core';\nimport { Context } from '../create-context';\nimport { ContextConsumer } from '../controllers/context-consumer';\n\n/**\n * A property decorator that marks a component property as a context consumer.\n * The decorated property will automatically receive values from the nearest context provider.\n *\n * @param options Configuration options\n * @param options.context Context identifier created via createContext\n * @param options.subscribe Whether to subscribe to context value changes, defaults to false.\n *                         If set to true, the property will automatically update when the context value changes\n * @param options.path Optional path string to specify which part of the context value to subscribe to\n *\n * @example\n * ```ts\n * import { Component } from '@stencil/core';\n * import { Consume } from '@src/core/context/decorators/consume';\n * import { themeContext } from '@src/context/theme-context';\n *\n * @Component({\n *   tag: 'theme-consumer'\n * })\n * export class ThemeConsumer {\n *   @Consume({ context: themeContext, subscribe: true, path: 'theme.current' })\n *   theme!: string;\n *\n *   render() {\n *     return <div class={this.theme}>Themed content</div>;\n *   }\n * }\n * ```\n */\nexport function Consume<ValueType>({\n  context,\n  subscribe = false,\n  path,\n}: {\n  context: Context<unknown, ValueType>;\n  subscribe?: boolean;\n  path?: string[] | (() => string[]);\n}) {\n  return (target: ComponentInterface & { __propsReady?: Promise<void> }, propertyKey: string) => {\n    const originalConnectedCallback = target.connectedCallback;\n    const originalDisconnectedCallback = target.disconnectedCallback;\n\n    const consumerMap = new WeakMap<HTMLElement, ContextConsumer<Context<unknown, ValueType>, HTMLElement>>();\n\n    target.connectedCallback = function () {\n      // Create and initialize ContextConsumer\n      const consumer = new ContextConsumer(getElement(this), {\n        context,\n        callback: (value) => {\n          this[propertyKey] = value;\n        },\n        subscribe,\n        path:\n          typeof path === 'function'\n            ? new Promise<() => string[]>((res) => {\n                if (this.__propsReady) {\n                  this.__propsReady.then(() => res(path.bind(this)));\n                } else {\n                  res(path.bind(this));\n                }\n              })\n            : path,\n      });\n      consumerMap.set(getElement(this), consumer);\n\n      consumer.hostConnected();\n\n      // Call original connectedCallback\n      if (originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    };\n\n    target.disconnectedCallback = function () {\n      // @ts-expect-error TYPE_FIXME. Please Fix the below strict mode type error. Read https://bytedance.sg.larkoffice.com/docx/MIsKdGOQwoQsnuxrsxEl6AsYgCf\n      consumerMap.get(getElement(this)).hostDisconnected();\n      consumerMap.delete(getElement(this));\n\n      // Call original disconnectedCallback\n      if (originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    };\n  };\n}\n"],"mappings":";;;;;SAiBaA,EAYX,WAAAC,CACEC,EACAC,EACAC,EACAC,EACAC,GAbMC,KAASF,UAAG,MAGZE,KAAQC,SAAG,MAEnBD,KAAKE,MAAoBC,UA8CjBH,KAAAI,UAA6C,CAACF,EAAOG,KAE3D,GAAIL,KAAKK,YAAa,CAEpB,GAAIL,KAAKK,cAAgBA,EAAa,CAEpCL,KAAKC,SAAW,MAChBD,KAAKK,a,CAGP,IAAKL,KAAKF,UAAW,CACnBE,KAAKK,a,EAKTL,KAAKE,MAAQA,EAEbI,EAAYN,KAAKL,MAIjB,IAAKK,KAAKC,UAAYD,KAAKF,UAAW,CACpCE,KAAKC,SAAW,KAChB,GAAID,KAAKH,SAAU,CACjBG,KAAKH,SAASK,EAAOG,E,EAIzBL,KAAKK,YAAcA,CAAW,EAjE9BL,KAAKL,KAAOA,EAGZ,GAAKC,EAAgCW,UAAYJ,UAAW,CAC1D,MAAMK,EAAUZ,EAChBI,KAAKO,QAAUC,EAAQD,QACvBP,KAAKH,SAAWW,EAAQX,SACxBG,KAAKF,UAAYU,EAAQV,WAAa,MACtCE,KAAKD,KAAOS,EAAQT,I,KACf,CACLC,KAAKO,QAAUX,EACfI,KAAKH,SAAWA,EAChBG,KAAKF,UAAYA,GAAa,MAC9BE,KAAKD,KAAOA,C,EAMhB,aAAAU,GACET,KAAKU,iB,CAGP,gBAAAC,GACE,GAAIX,KAAKK,YAAa,CACpBL,KAAKK,cACLL,KAAKK,YAAcF,S,EAIf,eAAAO,GACNV,KAAKL,KAAKiB,cAAc,IAAIC,EAAoBb,KAAKO,QAASP,KAAKI,UAAWJ,KAAKF,UAAWE,KAAKD,M;;;;GC7BjG,SAAUe,GAAmBP,QACjCA,EAAOT,UACPA,EAAY,MAAKC,KACjBA,IAMA,MAAO,CAACgB,EAA+DC,KACrE,MAAMC,EAA4BF,EAAOG,kBACzC,MAAMC,EAA+BJ,EAAOK,qBAE5C,MAAMC,EAAc,IAAIC,QAExBP,EAAOG,kBAAoB,WAEzB,MAAMK,EAAW,IAAI9B,EAAgB+B,EAAWxB,MAAO,CACrDO,UACAV,SAAWK,IACTF,KAAKgB,GAAed,CAAK,EAE3BJ,YACAC,YACSA,IAAS,WACZ,IAAI0B,SAAyBC,IAC3B,GAAI1B,KAAK2B,aAAc,CACrB3B,KAAK2B,aAAaC,MAAK,IAAMF,EAAI3B,EAAK8B,KAAK7B,Q,KACtC,CACL0B,EAAI3B,EAAK8B,KAAK7B,M,KAGlBD,IAERsB,EAAYS,IAAIN,EAAWxB,MAAOuB,GAElCA,EAASd,gBAGT,GAAIQ,EAA2B,CAC7BA,EAA0Bc,KAAK/B,K,CAEnC,EAEAe,EAAOK,qBAAuB,WAE5BC,EAAYW,IAAIR,EAAWxB,OAAOW,mBAClCU,EAAYY,OAAOT,EAAWxB,OAG9B,GAAImB,EAA8B,CAChCA,EAA6BY,KAAK/B,K,CAEtC,CAAC,CAEL,Q","ignoreList":[]}