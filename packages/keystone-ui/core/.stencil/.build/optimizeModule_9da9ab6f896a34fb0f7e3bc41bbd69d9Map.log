{"version":3,"names":["ValueNotifier","value","this","_value","v","setValue","force","_oldValue","callback","disposer","path","subscriptions","Object","is","Promise","then","newValue","get","oldValue","constructor","defaultValue","Map","undefined","addCallback","consumerHost","subscribe","pathValue","has","set","delete","clearCallbacks","clear","ContextProviderEvent","Event","context","super","bubbles","composed","ContextProvider","host","contextOrOptions","initialValue","onContextRequest","ev","composedPath","stopPropagation","contextPath","onProviderRequest","childProviderHost","seen","Set","add","dispatchEvent","ContextRequestEvent","attachListeners","addEventListener","detachListeners","removeEventListener","hostConnected","hostDisconnected","Provide","target","propertyKey","controllerMap","WeakMap","pendingValueMap","originalConnectedCallback","connectedCallback","originalDisconnectedCallback","disconnectedCallback","controller","getElement","pendingValue","call","currentController","descriptor","getOwnPropertyDescriptor","newDescriptor","valueMap","configurable","enumerable","oldSetter","defineProperty"],"sources":["src/libs/runtime-context/value-notifier.ts","src/libs/runtime-context/controllers/context-provider.ts","src/libs/runtime-context/decorators/provide.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { get } from 'lodash-es';\nimport { ContextCallback } from './context-request-event';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\ninterface CallbackInfo {\n  disposer: Disposer;\n  consumerHost: Element;\n  path?: string[] | Promise<() => string[]>;\n}\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  protected readonly subscriptions = new Map<ContextCallback<T>, CallbackInfo>();\n  private _value!: T;\n  get value(): T {\n    return this._value;\n  }\n  set value(v: T) {\n    this.setValue(v);\n  }\n\n  setValue(v: T, force = false) {\n    const _oldValue = this._value;\n    this._value = v;\n    for (const [callback, { disposer, path }] of this.subscriptions) {\n      if (!path) {\n        // 没有路径，检查全值\n        if (force || !Object.is(this._value, _oldValue)) {\n          callback(this._value, disposer);\n        }\n      } else if (path instanceof Promise) {\n        path.then((path) => {\n          // 只在路径值变化时才触发回调\n          const newValue = get(this._value, path());\n          const oldValue = get(_oldValue, path());\n          if (force || !Object.is(newValue, oldValue)) {\n            callback(newValue, disposer);\n          }\n        });\n      } else {\n        // 路径已解析，比较路径值是否变化触发回调\n        const newValue = get(this._value, path);\n        const oldValue = get(_oldValue, path);\n        if (force || !Object.is(newValue, oldValue)) {\n          callback(newValue, disposer);\n        }\n      }\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  addCallback(\n    callback: ContextCallback<T>,\n    consumerHost: Element,\n    subscribe?: boolean,\n    path?: string[] | Promise<() => string[]>,\n  ): void {\n    if (!subscribe) {\n      // 如果不订阅，初始化后直接返回\n      if (!path) {\n        callback(this.value);\n      } else if (path instanceof Promise) {\n        path.then((path) => {\n          const pathValue = get(this.value, path());\n          callback(pathValue);\n        });\n      } else {\n        const pathValue = get(this.value, path);\n        callback(pathValue);\n      }\n      return;\n    }\n\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost,\n        path,\n      });\n    }\n    const { disposer } = this.subscriptions.get(callback)!;\n\n    if (!path) {\n      callback(this.value, disposer);\n    } else if (path instanceof Promise) {\n      path.then((path) => {\n        const pathValue = get(this.value, path());\n        callback(pathValue, disposer);\n      });\n    } else {\n      const pathValue = get(this.value, path);\n      callback(pathValue, disposer);\n    }\n  }\n\n  clearCallbacks(): void {\n    this.subscriptions.clear();\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport { ContextRequestEvent } from '../context-request-event';\nimport { ValueNotifier } from '../value-notifier';\nimport type { Context, ContextType } from '../create-context';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<C extends Context<unknown, unknown>> extends Event {\n  readonly context: C;\n\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  constructor(context: C) {\n    super('context-provider', { bubbles: true, composed: true });\n    this.context = context;\n  }\n}\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  initialValue?: ContextType<C>;\n}\n\nexport class ContextProvider<\n  T extends Context<unknown, unknown>,\n  HostElement extends HTMLElement = HTMLElement,\n> extends ValueNotifier<ContextType<T>> {\n  protected readonly host: HostElement;\n  private readonly context: T;\n\n  constructor(host: HostElement, options: Options<T>);\n  constructor(host: HostElement, contextOrOptions: T | Options<T>, initialValue?: ContextType<T>) {\n    super(\n      (contextOrOptions as Options<T>).context !== undefined\n        ? (contextOrOptions as Options<T>).initialValue\n        : initialValue,\n    );\n    this.host = host;\n    if ((contextOrOptions as Options<T>).context !== undefined) {\n      this.context = (contextOrOptions as Options<T>).context;\n    } else {\n      this.context = contextOrOptions as T;\n    }\n    this.attachListeners();\n  }\n\n  onContextRequest = (ev: ContextRequestEvent<Context<unknown, unknown>>): void => {\n    // Only call the callback if the context matches.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    // The check on composedPath (as opposed to ev.target) is to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    const consumerHost = ev.composedPath()[0] as Element;\n    if (ev.context !== this.context || consumerHost === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, consumerHost, ev.subscribe, ev.contextPath);\n  };\n\n  /**\n   * When we get a provider request event, that means a child of this element\n   * has just woken up. If it's a provider of our context, then we may need to\n   * re-parent our subscriptions, because is a more specific provider than us\n   * for its subtree.\n   */\n  onProviderRequest = (ev: ContextProviderEvent<Context<unknown, unknown>>): void => {\n    // Ignore events when the context doesn't match.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context it shouldn't provide to itself.\n    // We use composedPath (as opposed to ev.target) to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    const childProviderHost = ev.composedPath()[0] as Element;\n    if (ev.context !== this.context || childProviderHost === this.host) {\n      return;\n    }\n    // Re-parent all of our subscriptions in case this new child provider\n    // should take them over.\n    const seen = new Set<unknown>();\n    for (const [callback, { consumerHost, path }] of this.subscriptions) {\n      // Prevent infinite loops in the case where a one host element\n      // is providing the same context multiple times.\n      //\n      // While normally it's a no-op to attempt to re-parent a subscription\n      // that already has its proper parent, in the case where there's more\n      // than one ValueProvider for the same context on the same hostElement,\n      // they will each call the consumer, and since they will each have their\n      // own dispose function, a well behaved consumer will notice the change\n      // in dispose function and call their old one.\n      //\n      // This will cause the subscriptions to thrash, but worse, without this\n      // set check here, we can end up in an infinite loop, as we add and remove\n      // the same subscriptions onto the end of the map over and over.\n      if (seen.has(callback)) {\n        continue;\n      }\n      seen.add(callback);\n      consumerHost.dispatchEvent(new ContextRequestEvent(this.context, callback, true, path));\n    }\n    ev.stopPropagation();\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n\n  private detachListeners() {\n    this.host.removeEventListener('context-request', this.onContextRequest);\n    this.host.removeEventListener('context-provider', this.onProviderRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n\n  hostDisconnected(): void {\n    this.detachListeners();\n    this.clearCallbacks();\n  }\n}\n","/**\n * @license\n * Copyright 2024 ByteDance Inc.\n */\n\nimport { ComponentInterface, getElement } from '@stencil/core';\nimport { Context } from '../create-context';\nimport { ContextProvider } from '../controllers/context-provider';\n\ntype StencilComponentRef = unknown;\n\n/**\n * A property decorator that marks a component property as a context provider.\n * The decorated property value will be provided to consuming components through the context system.\n *\n * @param options Configuration options\n * @param options.context Context identifier created via createContext\n *\n * @example\n * ```ts\n * import { Component } from '@stencil/core';\n * import { Provide } from '@src/core/context/decorators/provide';\n * import { themeContext } from '@src/context/theme-context';\n *\n * @Component({\n *   tag: 'theme-provider'\n * })\n * export class ThemeProvider {\n *   @Provide({ context: themeContext })\n *   theme = 'light';\n * }\n * ```\n */\nexport function Provide<ValueType>({\n  context,\n  callback,\n}: {\n  context: Context<unknown, ValueType>;\n  callback?: (instance: StencilComponentRef, value: ValueType) => void;\n}) {\n  return (target: ComponentInterface, propertyKey: string) => {\n    // Store mapping between component instances and their ContextProvider controllers\n    const controllerMap = new WeakMap<HTMLElement, ContextProvider<Context<unknown, ValueType>>>();\n    // Store pending values before component connection\n    const pendingValueMap = new WeakMap<HTMLElement, ValueType>();\n\n    const originalConnectedCallback = target.connectedCallback;\n    const originalDisconnectedCallback = target.disconnectedCallback;\n\n    target.connectedCallback = function () {\n      // Create and initialize ContextProvider\n      const controller = new ContextProvider(getElement(this), { context, initialValue: this[propertyKey] });\n      // @ts-expect-error TYPE_FIXME. Please Fix the below strict mode type error. Read https://bytedance.sg.larkoffice.com/docx/MIsKdGOQwoQsnuxrsxEl6AsYgCf\n      this.controller = controller;\n      controllerMap.set(getElement(this), controller);\n\n      // If there's a pending value, set it to the provider\n      const pendingValue = pendingValueMap.get(getElement(this));\n      if (pendingValue !== undefined) {\n        controller.setValue(pendingValue);\n        pendingValueMap.delete(getElement(this));\n      }\n\n      controller.hostConnected();\n\n      // Call original connectedCallback\n      if (originalConnectedCallback) {\n        originalConnectedCallback.call(this);\n      }\n    };\n\n    target.disconnectedCallback = function () {\n      const currentController = controllerMap.get(getElement(this));\n      if (currentController) {\n        currentController.hostDisconnected();\n        controllerMap.delete(getElement(this));\n      }\n\n      // Call original disconnectedCallback\n      if (originalDisconnectedCallback) {\n        originalDisconnectedCallback.call(this);\n      }\n    };\n\n    // Create accessor for the target property\n    const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey);\n    let newDescriptor: PropertyDescriptor;\n    if (descriptor === undefined) {\n      // If property has no descriptor, create new accessors\n      const valueMap = new WeakMap<HTMLElement, ValueType>();\n      newDescriptor = {\n        get(this: StencilComponentRef) {\n          return valueMap.get(getElement(this));\n        },\n        set(this: StencilComponentRef, value: ValueType) {\n          const controller = controllerMap.get(getElement(this));\n          if (controller) {\n            controller.setValue(value);\n          } else {\n            // If controller is not yet created, store value in pending map\n            pendingValueMap.set(getElement(this), value);\n          }\n          valueMap.set(getElement(this), value);\n          callback?.(this, value);\n        },\n        configurable: true,\n        enumerable: true,\n      };\n    } else {\n      // If property has descriptor, preserve existing behavior and add value update logic\n      const oldSetter = descriptor.set;\n      newDescriptor = {\n        ...descriptor,\n        set(this: HTMLElement, value: ValueType) {\n          controllerMap.get(getElement(this))!.setValue(value);\n          oldSetter?.call(this, value);\n          callback?.(this, value);\n        },\n      };\n    }\n    Object.defineProperty(target, propertyKey, newDescriptor);\n  };\n}\n"],"mappings":"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","ignoreList":[]}